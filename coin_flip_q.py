# -*- coding: utf-8 -*-
"""coin_flip_Q.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_pfWhHIfzzAa40WPJefRPPYApv7ECwQS
"""

#1
import numpy as np
from fractions import Fraction as frac
Pr = {}
n = 100
for s in range(- 3 * n, 3 * n + 1):
    Pr[(n, s)] = frac(int(s > 0))
for r in reversed(range(n)):
    for s in range(-3 * r, 3 * r + 1):
        flipping_x = frac(1, 2) * (Pr[(r + 1, s - 1)] + \
                                  Pr[(r + 1, s + 1)])
        flipping_y = frac(1, 2) * (Pr[(r + 1, s - 3)] + \
                                  Pr[(r + 1, s + 3)])
        if flipping_x > flipping_y or (flipping_x == flipping_y and s > 0):
            Pr[(r, s)] = flipping_x
        else:
            Pr[(r, s)] = flipping_y
float(Pr[(0, 0)])

#2
from collections import namedtuple
class GameState(namedtuple("GameState", ("n_flip", "score"))):
    cache: dict = {}  
    p_a: float = 0.5  
    p_b: float = 0.5  
    v_a: int = 1      
    v_b: int = 3      
    def expected_value(self) -> float:  
        try:
            return self.cache[self]
        except KeyError: 
            if self.n_flip == 100:
                if self.score > 0:
                    self.cache[self] = 1.0
                else:
                    self.cache[self] = 0.0
            else:
                
                n, s = self.n_flip + 1, self.score
                a = (
                    self.p_a * GameState(n, s+ self.v_a).expected_value()
                    + (1 - self.p_a) * GameState(n, s - self.v_a).expected_value()
                )
                b = (
                    self.p_b * GameState(n, s + self.v_b).expected_value()
                    + (1 - self.p_b) * GameState(n, s - self.v_b).expected_value()
                )
                self.cache[self] = max(a, b)
            return self.cache[self]
if __name__ == "__main__":
    import doctest
    doctest.testmod()
GameState(0, 0).expected_value()

#3
#change 3
import numpy as np
def compute_win_prob( a, b, N ):    
    v = np.zeros(4*N+1)
    v[:2*N] = 0
    v[2*N+1:] = 1
    for t in range(N):
        coin_A = a*v[3:4*N] + (1-a)*v[1:4*N-2]
        coin_B = b*v[4:4*N+1] + (1-b)*v[0:4*N-3]
        v[2:4*N-1] = np.maximum(coin_A, coin_B)
    return v[2*N]
compute_win_prob(0.5,0.5,100)